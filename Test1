package com.example.multidb.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

@Configuration
public class SecondaryDbConfig {

    /**
     * Creates the DataSource bean for the secondary database.
     * Properties are loaded from application.properties using the specified prefix.
     */
    @Bean(name = "secondaryDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    /**
     * Creates a JdbcTemplate bean that is wired to the secondary DataSource.
     * This is the main tool for executing native queries.
     * @param dataSource The secondary DataSource bean.
     * @return A configured JdbcTemplate instance.
     */
    @Bean(name = "secondaryJdbcTemplate")
    public JdbcTemplate secondaryJdbcTemplate(@Qualifier("secondaryDataSource") DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

    /**
     * Creates a transaction manager for the secondary DataSource.
     * Since we are not using JPA, we use DataSourceTransactionManager.
     * @param dataSource The secondary DataSource bean.
     * @return A transaction manager for JDBC operations.
     */
    @Bean(name = "secondaryTransactionManager")
    public PlatformTransactionManager secondaryTransactionManager(@Qualifier("secondaryDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}



package com.example.multidb.secondary.repository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class SecondaryDbCustomRepository {

    private final JdbcTemplate jdbcTemplate;

    /**
     * Injects the secondary JdbcTemplate bean.
     * @param jdbcTemplate The JdbcTemplate configured for the secondary database.
     */
    @Autowired
    public SecondaryDbCustomRepository(@Qualifier("secondaryJdbcTemplate") JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    /**
     * Executes a native SQL UPDATE statement to modify specific columns.
     * @param id The ID of the record to update.
     * @param name The new name value.
     * @param status The new status value.
     * @return The number of rows affected by the update.
     */
    public int updateUserColumns(Long id, String name, String status) {
        // IMPORTANT: Use your actual table and column names in the query.
        String sql = "UPDATE secondary_user SET name = ?, status = ? WHERE id = ?";
        return jdbcTemplate.update(sql, name, status, id);
    }
}


package com.example.multidb.service;

import com.example.multidb.primary.entity.PrimaryUser;
import com.example.multidb.primary.repository.PrimaryUserRepository;
import com.example.multidb.secondary.repository.SecondaryDbCustomRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Recover;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UpdateService {

    private static final Logger logger = LoggerFactory.getLogger(UpdateService.class);

    @Autowired
    private PrimaryUserRepository primaryUserRepository;

    @Autowired
    private SecondaryDbCustomRepository secondaryDbCustomRepository; // Inject the new repository

    @Transactional("primaryTransactionManager")
    public void updateUserInPrimary(PrimaryUser user) {
        primaryUserRepository.save(user);
    }

    /**
     * Updates the secondary database within a transaction.
     * This method is now retryable on DataAccessException.
     */
    @Transactional("secondaryTransactionManager") // Point to the new JDBC transaction manager
    @Retryable(
        value = { DataAccessException.class }, // Catch Spring's generic data access exceptions
        maxAttempts = 3,
        backoff = @Backoff(delay = 2000)
    )
    public void updateUserInSecondary(Long id, String name, String status) {
        logger.info("Attempting to update secondary database using JdbcTemplate...");
        secondaryDbCustomRepository.updateUserColumns(id, name, status);
        logger.info("Successfully updated secondary database using JdbcTemplate.");
    }

    /**
     * Recovery method that is called after all retry attempts fail.
     */
    @Recover
    public void recover(DataAccessException e, Long id, String name, String status) {
        logger.error("Failed to update secondary database after multiple retries for user ID: " + id, e);
        // Implement your fallback logic here (e.g., log to a dead-letter queue).
    }

    /**
     * Orchestrates the update to both databases.
     */
    public void updateBothDatabases(PrimaryUser primaryUser) {
        try {
            updateUserInPrimary(primaryUser);
            logger.info("Successfully updated primary database.");
        } catch (Exception e) {
            logger.error("Failed to update primary database. Aborting operation.", e);
            return; // Stop if the primary update fails
        }

        try {
            // Call the updated service method
            updateUserInSecondary(primaryUser.getId(), primaryUser.getName(), "UPDATED");
        } catch (DataAccessException e) {
            // The @Recover method will be called automatically by Spring Retry.
            // We can log the initial failure for immediate visibility.
            logger.error("Initial attempt to update secondary database failed. Retry mechanism will engage.", e);
        }
    }
}
